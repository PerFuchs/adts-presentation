<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css">
    <link rel="stylesheet" href="custom_theme.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>Testing as a service:<br> making a vision tangible</h2>
            <br>
            <h3>Presented by Per</h3>
        </section>
        <section>
            <h3>Bigger software == more bugs</h3>
            <ul>
                <li>average bug density stayed constant</li>
                <li class="space-below">but average code volume increases exponentially</li>
                <li>software steers evermore important processes in our society e.g. micro trading</li>
            </ul>
            <ul>

            </ul>
            <aside class="notes">
                <p>
                    So far the headline is true. A study showed that the bug density over time stayed
                    constant while the size of software increased exponentially. Therefore,
                    we find evermore bugs.
                </p>
                <p>
                    This needs to change, not only because bugs are expensive as other papers showed but
                    especially because software controls important aspects of our society and lives e.g.
                    micro trading.
                </p>
                <p>
                    People start presentation about testing with the columbia spaceshuttle dissaster
                    as an example. I believe, this example does not cover the modern situation anymore.
                    Let me explain, back then this disaster mostly hit the producers and users of the
                    software - the NASA. Nowadays, a bug causing a micro trading service to go haywire
                    might cause insolvency of a single bank but wide spread finicial crisis. Affecting,
                    not only a single company but the whole western society.
                </p>
                <p>Therefore, it becomes a social responsibility to deliver good software.</p>
            </aside>
        </section>
        <section>
            <h3>Automated software testing as a service (TaaS)</h3>
            <ul>
                <li>fully automated testing by a service provider</li>
                <li>on managed infrastructure</li>
                <li class="space-below">saving developing time and money</li>
                <li>makes software reliability comparable and promotes open competition along this metric</li>
            </ul>
        </section>
        <section>
            <h3>My objective: making TaaS tangible</h3>
            <ul class="dashed">
                <li>TaaS is a vision and might seems unrealistic or far-off</li>
                <li class="space-below">but most of its challenges are subject of state of art research</li>
                <li>The presented papers illustrate</li>
                <ul>
                    <li>one possible implementation of TaaS by PaaS providers</li>
                    <li>a promising approach to make symbolic execution scalable on a share-nothing
                        architecture
                    </li>
                </ul>
            </ul>

            <aside class="notes">
                <p>
                    My main question after reading the vision paper about Taas was: "Great story but
                    where is the substance/ the solutions
                </p>
                <p>
                    Turned out there are papers that work on most challenges mentioned in the
                    vision papers filling in these gaps.
                </p>
                <p>
                    I chose two of those.
                </p>
                <p>
                    show one possible implementation of TaaS which is really
                    high level but shows a concrete design for TaaS
                </p>
                <p>
                    one technical paper to illustrate that to many technical challenges
                    promising approaches are existing in current research
                </p>


                <p>
                    central or left aligned?
                    as sentence or bullet points
                    more space to the headline
                    slide numbers

                </p>
            </aside>
        </section>
        <section>
            <h3>Structure</h3>
            <ol>
            </ol>
        </section>
        <section>
            <h3>Symbolic Execution</h3>
        </section>
        <section>
            <section>
                <h3>TaaS by PaaS providers</h3>
                <h4>One possible implementation of TaaS</h4>
                <aside class="notes">
                    Introduction as one possible implementation instead of a definitive manual to it
                    that does not go into technical details
                </aside>
            </section>
            <section>
                <h3>TaaS by PaaS providers</h3>
                <ul>
                    <li>PaaS streamlines deploying from apps</li>
                    <li class="space-below">PaaS providers are well positioned to also simplify the testing of apps</li>
                    <li>They already provide the setup of dependencies for integration testing</li>
                    <li>but leave the developer with the hard task to handcraft requests for each test scenario</li>
                    <ul>
                        <li>this is a tedious task even more so because of the layered architecture of modern web apps
                        </li>
                    </ul>
                    <aside class="notes">
                        <p>Message: the main idea of TaaS by Paas + why is it intuitively feasible</p>
                        <p>Economically well positioned as well</p>
                        <p>
                            Example layers: HTTP parsing, URL dispatching, JSON parsing, Business logic,
                            Test case only wants to exercise all paths in the business logic but needs to fulfill
                            conditions at each layer
                        </p>
                        <p>This is the concrete problem of the presented approach</p>
                        <p>Developers input: application + one testcase per input of the same structure and
                            same assertations (e.g. no 500 error + all possible execution paths through one
                            url handler</p>
                    </aside>
                </ul>
            </section>
            <section>
                <div class="box">
                    <div class="col-60">
                        <img src="img/paas_test_case.png">
                    </div>
                    <div class="col-40">
                    <img src="img/paas_request.png">
                        <ol>
                            <li>Defines inputs and their structure</li>
                            <li>Retrieves concrete input</li>
                            <li>Processes request and computes path constraints</li>
                            <li>Repeat steps with new input generated by negating path constraints</li>
                        </ol>
                    </div>
                </div>
                <aside class="notes">
                    <TODO>add numbers to pictures</TODO>
                    <TODO>slide about new input generation</TODO>
                    <p>Message: this is how a test case looks like and how it is executed</p>
                    <p>Setup: Define input and their structure as onion object</p>
                    <p>Talk to the payload of the example</p>
                    <p>mention wrapping in json and http (prepared structures</p>
                    <p>point out layer parapmeter</p>
                    <p>point out definition and naming</p>
                    <p>running: gets the input by name, that is one concrete good input</p>
                    <p>instruments it for symbolic execution (only one layer)</p>
                    <p>processes request (concrete)</p>
                    <p>at the same time collects path constraints for this single path (symbolic)</p>
                    <p>Get new inputs</p>
                    <p>by generating inputs out of path constraints: negate a single one for interesting layers build a correct input (cross layer dependencies (e.g. http size field to content size))</p>
                </aside>

            </section>
            <section>
                <h3>Intuition behind the idea</h3>
                <ul>
                    <li class="space-below">automates valid input generation to cover whole families of inputs</li>
                    <li>executes only single paths symbolically</li>
                    <li class="space-below">uses layering structure to focus testing on interesting parts</li>
                    <li>fits the already existing business model of PaaS providers</li>
                    <ul>
                        <li>the paper provides an idea how to setup testing machines</li>
                        <li>basically wrapping a production machine in a symbolic VM</li>
                    </ul>
                </ul>
                <aside class="notes">
                    <TODO>slide about test server setup</TODO>
                    <p>Message: repeat, clearify main ideas of PaaS testing</p>
                    <TODO>can i add the fitting of PaaS business model?</TODO>
                    <ul>
                        <li>What does this achieve?</li>
                        <li>Automates test input generation to automatically cover many paths based on
                        input structure. One could say generates input "inteligently"
                        </li>
                        <ul>
                            <li>high success rate in generating inputs that</li>
                            <ul>
                                <li>cover new paths</li>
                                <li>are "correct" inputs</li>
                            </ul>
                        </ul>
                        <li>Executes only single paths symbolically: No path explosion, can never explore all paths</li>
                        <li>Uses common structure to focus on business logic instead of library code</li>
                        <li>As PaaS provider are already able to build production machines they are well suited
                        to build similiar test machines, basically wrapping a production machine in a
                        symbolic VM and implement the testing framework</li>
                    </ul>
                </aside>
            </section>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    Reveal.initialize({
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ],
        controls: false,
        width: 1500,
        margin: 0.05,
        center: true,
        transition: "slide"
    });
    Reveal.configure({ slideNumber: true });
    Reveal.configure({ slideNumber: 'c/t' });
</script>
</body>
</html>
