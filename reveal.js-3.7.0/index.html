<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css">
    <link rel="stylesheet" href="custom_theme.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>Testing as a service:<br> making a vision tangible</h2>
            <br>
            <h3>Presented by Per Fuchs</h3>
            <h5>Course Advanced Topics in Distributed Systems 2018</h5>
        </section>
        <section>
            <h3>Bigger software == more bugs</h3>
            <ul>
                <li>average bug density stayed constant</li>
                <li class="space-below">but average code volume increases exponentially</li>
                <li>software steers evermore important processes in our society e.g. micro trading</li>
            </ul>
            <ul>

            </ul>
            <aside class="notes">
                <p>
                    So far the headline is true. A study showed that the bug density over time stayed
                    constant while the size of software increased exponentially. Therefore,
                    we find evermore bugs.
                </p>
                <p>
                    This needs to change, not only because bugs are expensive as other papers showed but
                    especially because software controls important aspects of our society and lives e.g.
                    micro trading.
                </p>
                <p>
                    People start presentation about testing with the columbia spaceshuttle dissaster
                    as an example. I believe, this example does not cover the modern situation anymore.
                    Let me explain, back then this disaster mostly hit the producers and users of the
                    software - the NASA. Nowadays, a bug causing a micro trading service to go haywire
                    might cause insolvency of a single bank but wide spread finicial crisis. Affecting,
                    not only a single company but the whole western society.
                </p>
                <p>Therefore, it becomes a social responsibility to deliver good software.</p>
            </aside>
        </section>
        <section>
            <h3>Automated software testing as a service (TaaS)</h3>
            <ul>
                <li>fully automated testing by a service provider</li>
                <li>on managed infrastructure</li>
                <li class="space-below">saving developing time and money</li>
                <li>makes software reliability comparable and promotes open competition along this metric</li>
            </ul>
        </section>
        <section>
            <h3>Making TaaS tangible: Structure</h3>
            <ol class="dashed">
                <li>preliminaries: what is symbolic execution?</li>
                <li>a concrete example on how to build TaaS for PaaS</li>
                <li>solution for a technical challenge: parallelize symbolic execution</li>
                <li>TaaS a disruptive technology</li>
            </ol>
            </ul>

            <aside class="notes">
                <p>
                    My main question after reading the vision paper about Taas was: "Great story but
                    where is the substance/ the solutions
                </p>
                <p>
                    Turned out there are papers that work on most challenges mentioned in the
                    vision papers filling in these gaps.
                </p>
                <p>
                    I chose two of those.
                </p>
                <p>
                    show one possible implementation of TaaS which is really
                    high level but shows a concrete design for TaaS
                </p>
                <p>
                    one technical paper to illustrate that to many technical challenges
                    promising approaches are existing in current research
                </p>


                <p>
                    central or left aligned?
                    as sentence or bullet points
                    more space to the headline
                    slide numbers

                </p>
            </aside>
        </section>
        <section>
            <h3>Symbolic Execution</h3>
            <div class="box">
                <div class="col-50">
<pre><code class="hljs" data-trim contenteditable>
i = get_int()
if (i==9):
    fail()
else:
    print(i)
</code></pre>
                </div>
                <div class="col-50">
                    <img src="graphs/symbex.png">
                </div>
            </div>
        </section>
        <section>
            <section>
                <h3>TaaS by PaaS providers</h3>
                <h4>One possible implementation of TaaS</h4>
                <aside class="notes">
                    Introduction as one possible implementation instead of a definitive manual to it
                    that does not go into technical details
                </aside>
            </section>
            <section>
                <h3>TaaS by PaaS providers</h3>
                <ul>
                    <li>PaaS providers are well positioned to also simplify the integration testing of apps</li>
                    <li>they already provide the setup of dependencies for integration testing</li>
                    <li>but leave the developer with the hard task to handcraft requests for each test scenario</li>
                    <ul>
                        <li>this is a tedious task even more so because of the layered architecture of modern web apps
                        </li>
                    </ul>
                    <aside class="notes">
                        <p>Message: the main idea of TaaS by Paas + why is it intuitively feasible</p>
                        <p>Economically well positioned as well</p>
                        <p>
                            Example layers: HTTP parsing, URL dispatching, JSON parsing, Business logic,
                            Test case only wants to exercise all paths in the business logic but needs to fulfill
                            conditions at each layer
                        </p>
                        <p>This is the concrete problem of the presented approach</p>
                        <p>Developers input: application + one testcase per input of the same structure and
                            same assertations (e.g. no 500 error + all possible execution paths through one
                            url handler</p>
                    </aside>
                </ul>
            </section>
            <section>
                <div class="box">
                    <div class="col-60">
                        <img src="img/paas_test_case.png">
                    </div>
                    <div class="col-40">
                        <img src="img/paas_request.png">
                        <ol>
                            <li>Defines inputs and their structure</li>
                            <li>Retrieves concrete input</li>
                            <li>Concretely and symbolical executes request in parallel</li>
                            <li>Repeat steps with new input generated by negating path constraints</li>
                        </ol>
                    </div>
                </div>
                <aside class="notes">
                    <TODO>add numbers to pictures</TODO>
                    <TODO>slide about new input generation</TODO>
                    <p>Message: this is how a test case looks like and how it is executed</p>
                    <p>Setup: Define input and their structure as onion object</p>
                    <p>Talk to the payload of the example</p>
                    <p>mention wrapping in json and http (prepared structures</p>
                    <p>point out layer parapmeter</p>
                    <p>point out definition and naming</p>
                    <p>running: gets the input by name, that is one concrete good input</p>
                    <p>instruments it for symbolic execution (only one layer)</p>
                    <p>processes request (concrete)</p>
                    <p>at the same time collects path constraints for this single path (symbolic)</p>
                    <p>Get new inputs</p>
                    <p>by generating inputs out of path constraints: negate a single one for interesting layers build a
                        correct input (cross layer dependencies (e.g. http size field to content size))</p>
                </aside>

            </section>
            <section>
                <h3>Intuition behind the idea</h3>
                <ul>
                    <li class="space-below">automates valid input generation to cover whole families of inputs</li>
                    <li>deals with path explosion by executing only single paths symbolically</li>
                    <li class="space-below">uses layering structure to focus testing on interesting parts</li>
                    <li>furthermore, the paper provides how to setup a testing machine given a production machine</li>
                    <ul>
                        <li>basically wrapping a production machine in a symbolic VM</li>
                    </ul>
                </ul>
                <aside class="notes">
                    <TODO>slide about test server setup</TODO>
                    <p>Message: repeat, clearify main ideas of PaaS testing</p>
                    <TODO>can i add the fitting of PaaS business model?</TODO>
                    <ul>
                        <li>What does this achieve?</li>
                        <li>Automates test input generation to automatically cover many paths based on
                            input structure. One could say generates input "inteligently"
                        </li>
                        <ul>
                            <li>high success rate in generating inputs that</li>
                            <ul>
                                <li>cover new paths</li>
                                <li>are "correct" inputs</li>
                            </ul>
                        </ul>
                        <li>Executes only single paths symbolically: No path explosion, can never explore all paths</li>
                        <li>Uses common structure to focus on business logic instead of library code</li>
                        <li>As PaaS provider are already able to build production machines they are well suited
                            to build similiar test machines, basically wrapping a production machine in a
                            symbolic VM and implement the testing framework
                        </li>
                    </ul>
                </aside>
            </section>

        </section>
        <section>
            <section>
                <h2>Parallel symbolic execution</h2>
                <h3>One general approach enable symbolic execution of real world programs</h3>
            </section>
            <section>
                <h3>Parallel symbolic execution, rewards and problems</h3>
                <ul>
                    <li>parallelize symbolic execution on large clusters of commodity hardware</li>
                    <ul>
                        <li class="space-below">share nothing architecture</li>
                    </ul>
                    <li>to alleviate high memory consumption due to path explosion</li>
                    <li class="space-below">to distribute CPU intensive path constraint solving</li>
                    <li>mostly a load balancing problem</li>
                </ul>
                <aside class="notes">
                    <p>Message: Goal, Rewards and problems of symbex parallelization</p>
                    <ul>
                        <li>Parallization on computers as available in the clouds</li>
                        <ul>
                            <li>large clusters of commodity hardware</li>
                            <li>without common memory</li>
                            <li>low bisection bandwidth</li>
                        </ul>
                        <li>Due to that two of the main challenges of symbex are relieved</li>
                        <ul>
                            <li>high memory consumption of state explosion (scales with number of nodes)</li>
                            <li>to distribute CPU intensive path constraint solving</li>
                        </ul>
                        <li class="space-below">Mostly that is a load balacing problem.</li>
                        <li>Due to</li>
                        <ul>
                            <li>Unpredictable work per state</li>
                            <ul>
                                <li>Different difficulty of constraints</li>
                            </ul>
                            <li>Undecidability of subtree size</li>
                            <ul>
                                <li>Different amount of state forking</li>
                            </ul>
                            <li>Flunctations in worker availability, cost and quality</li>
                        </ul>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>System overview and load balancing</h3>
                <div class="box">
                    <div class="col-50">
                        <img src="graphs/worker_coordinator.png">
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>Systems consists out of one coordinator (C) and multiple worker (R, S, T)</li>
                            <li>one job == one execution state</li>
                            <li class="space-below">each worker maintains a work queue</li>
                            <li>they update the coordinator about the length of their queue (1)</li>
                            <li>the coordinator issues requests to balance work (2)</li>
                            <li>workers exchange jobs (3)</li>
                        </ul>
                    </div>
                </div>
                <aside class="notes">
                    <ul>
                        <li>consists out of workers and one coordinator</li>
                        <li>Splitting within the state domain - a job equals a state</li>
                        <li>Each worker maintains a queue of jobs</li>
                        <li>They update the coordinator regularely about there job count</li>
                        <li>coordinator issues balancing requests - coordinator is not responsible for actual balancing
                            -- low load
                        </li>
                        <li>talk through example with picture</li>
                        <li>Special case of leaving and joining nodes are handled easily</li>


                        <li>Very simple but leads to linear scaling according to paper</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Challenges in load balancing</h3>
                <ul>
                    <li>space-efficient job encoding for low bandwidth networks</li>
                    <li>no duplicated work</li>
                    <li>completeness of the execution tree</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Challenges:</li>
                        <ul>
                            <li>Efficient job encoding for low bandwidth requirements</li>
                            <ul>
                                <li>Solution: send path towards node state</li>
                            </ul>
                            <li>Nonredundant work</li>
                            <li>Completeness</li>
                            <li>Next slide</li>
                        </ul>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Complete and non-redundant partitioning an intuition</h3>
                <div class="box">
                    <div class="col-50">
                        <img src="img/partioning_cloud_9.png">
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>each worker explores its local subtree</li>
                            <li>there are three kind of nodes:</li>
                            <ul>
                                <li><b>Candidates</b>: to be explored</li>
                                <li><b>Fence states</b>: explored by another node</li>
                                <li><b>Dead states</b>: completely explored</li>
                            </ul>

                        </ul>
                    </div>
                </div>
                <aside class="notes">
                    <ul>
                        <li>Every worker holds only the subtree its exploring locally</li>
                        <li>No node has a global execution tree</li>
                        <li>So we get the following picture: ...</li>
                        <li>Candidates are to explore, fences are explored somewhere else,
                            dead nodes have been fully explored and can be deleted
                        </li>
                        <li>Nodes to explore are always chosen from the candidates list!</li>
                        <li>When a node is sent to a neighbour it becomes a fence nodes</li>


                        <li>Candidates are intersection free, (1) initial situation, (2) each work transfer keeps it
                            that way, (3) exploration can not introduce redundancy
                        </li>
                        <li>Candidates are complete because each node ever created is either candidates, dead (fully
                            explored) or fence (somewhere else a candidate)
                        </li>
                        <li>Ask them to believe that this is none redundant and complete hint you have a backup slide
                        </li>

                    </ul>
                </aside>
            </section>
            <section>
                <h3>Complete and non-redundant partitioning an intuition</h3>
                <div class="box">
                    <div class="col-50">
                        <img src="img/partioning_cloud_9.png">
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>Complete</li>
                            <ul>
                                <li>initially all children of the root state are allocated</li>
                                <li>each new state is a candidate</li>
                                <li>candidates become either</li>
                                <ul>
                                    <li>dead when they are fully explored</li>
                                    <li>fence when send to another worker but they will be candidate there</li>
                                </ul>
                            </ul>
                        </ul>
                    </div>
                </div>
            </section>
            <section>
                <h3>Complete and non-redundant partitioning an intuition</h3>
                <div class="box">
                    <div class="col-50">
                        <img src="img/partioning_cloud_9.png">
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>Non-redundant</li>
                            <ul>
                                <li>initially the sets of candidates on different nodes is intersection</li>
                                <li>Work transfer keeps them intersection free</li>
                                <li>Exploration never creates the same state twice</li>
                            </ul>
                        </ul>
                    </div>
                </div>
            </section>
            <section>
                <h3>Conclusion</h3>
                <ul>
                    <li>the paper describes</li>
                    <ul>
                        <li>a parallelized version of symbolic execution</li>
                        <li>that scales linearly</li>
                        <li>on share-nothing cloud architecture</li>
                        <li>and further contributions, e.g. symbolic environments or implementation of a testing API
                        </li>
                    </ul>
                </ul>
            </section>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script src="plugin/highlight/highlight.js"></script>

<script>
    Reveal.initialize({
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
        ],
        controls: false,
        width: 1500,
        margin: 0.05,
        center: true,
        transition: "slide"
    });
    Reveal.configure({slideNumber: true});
    Reveal.configure({slideNumber: 'c/t'});
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
</body>
</html>
